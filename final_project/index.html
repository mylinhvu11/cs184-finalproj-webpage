<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>  
    div.padded {  
      padding-top: 0px;  
      padding-right: 100px;  
      padding-bottom: 0.25in;  
      padding-left: 100px;  
    }  
  </style> 
<title>Riya Kumar, Mylinh Vu, Ali Khan, Aarman Goel |  CS 184</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="style.css" media="screen" />
</head>
<body>
<br />
<h1 align="middle">Final Project: Sonic High Kick Dance</h1>
    <h2 align="middle">Riya Kumar, Mylinh Vu, Ali Khan, and Armaan Goel</h2>
    <h2 align="middle">https://mylinhvu11.github.io/cs184-finalproj-webpage/</h2>

    <div class="padded">

        <h3 align="middle">Abstract</h3>
        <p>Our project utilizes libraries and packages from WebGL to create an interface. 
          With the model, we used a glTF rigged model of Sonic from online to make the keyframes
          in Blender to create our animation. To implement it, we used interpolation through linear
          averaging between positions in relation to time to get the values in between the keyframes. 
          There are options with the accessors to attempt cubic interpolation; however, with our keyframes,
          linear interpolation was the simplest approach and still provided a smooth animation. We decided to 
          make our Sonic character do a high kick dance which was fun to see it get rendered through the React app.
          As an extension, we wanted to implement camera capture with a video frame that can sense a person and take 
          captures of the personâ€™s poses and then integrate it and have Sonic do the same movements. We were able to 
          capture poses and the future steps would include translating the 2D pose from the capture to the 3D models 
          of Sonic which may have to utilize depth interpolation to make the translation. </p>
      
      <h3 align="middle">Technical Approach</h3>
      <h3 align="middle">Main Attempt 1: Spatial Keyframing for Performance-driven Animation with Penguin</h3>
	    <div align="middle">
  		<table style="width=100%">
    		<tr>
      		<td>
        		<img src="radial_basis.png" align="middle" width="400px"/>
        	<figcaption align="middle">basic test 4 with default parameters</figcaption>
      		</td>
    		</tr>
  		</table>
	</div>
        <p>This equation interpolates positions where f(X) represents the interpolation function with all the values
          in between. dj represents the weights of how much the specific value of interpolation should affect the final
          project. cj is the specific position of the keyframe and P(X) is a one-degree polynomial function that gets
          added to the general position so that the general position of the model is correct in relation. </p>
	 
	<p> The importance of orthonormalization is to make sure that the vectors are scaled, corrected and pointed in 
	 the correct direction as the movement and not the opposite direction which can happen through the math done 
	 in the radial basis function. Although we seemed to be able to implement both of these algorithms with the 
	  given equation and the cross products for orthonormalization, we were unable to fully test it without
		testing our renderings. </p>
	    
	  <p>Spatial Keyframing by taking the interpolation from the Radial Basis Function and orthonormalization to 
		  be a realistic transformation to present the values. It tok in values from the input as the keyframes 
		  and keysets and used our given functions to interpolate them and save the values to be given as an
		  output that could be displayed on the screen.  </p>
	    
	 <p> Problems: We tried for days to implement an interface either using Ogre which is an open source 3D graphics
		 engine or OpenGL, both with libraries that should be able to provide us the resources to build an 
		 interface, but the code and tutorials that we found were mostly Linux based and we were unable to 
		 translate the code to be compatible with Mac. We learned that the larger scaled renderings were harder 
		 to be able to run with Mac due to the large scale data needed for animations in comparison to image 
		 renderings from earlier in the class. In addition, although we understood the algorithms needed to 
		 implement the spatial keyframing, the interface was found to be the most difficult part which caused
		 us to abort this attempt at the project since without the interface, we would be unable to provide a 
		 demo or physical animation. </p>
	    
	<h3 align="middle">Main Attempt 2: WebGL Sonic High Kick Dance Animation</h3>
	    <p> We implemented the structure of a resource document linked below to build our project.</p>
	    <p>Model: We used a rigged model of the character Sonic to create keyframes in Blender.
		    We exported this as a glTF file in order to integrate the Sonic keyframes with our code. </p>
	    


	    
        <h3 align="middle">Preliminary Results</h3>
        <p>Though our preliminary results do not include animation, we have produced a static penguin. We have also added limits so that the model does not
      over rotate or intersect with itself. Once we implement the main function we will be able to see some animation.  </p>
	    
	<h3 align="middle">Progress so Far</h3>
	<p>During the first week, we successfully identified the necessary files and data structures required for keyframe animations, as well as the essential 
		libraries for implementing the algorithms. However, we still need to determine how to import a Blender 3D model, including its rigging, into our 
		system. In the second week, we made progress by further developing our core code, incorporating special keyframing implementation. Our next step 
		is to build test files or create keyframe poses that will enable smooth transitions in the animation. For the third week, we have already 
		implemented radial basis functions and spatial keyframing. Although we have completed tasks across our targeted weeks, some tasks remain due to 
		the practical order of implementation. Thus, it was more sensible to complete certain tasks before others.</p>

	<h3 align="middle">Updated Work Plan</h3>

	<p>Week 3: Understand and implement radial basis function and orthonormalization from our base code with the matrices and values. Our code should start outputting 
		fluid animations or attempts to. Have the userface able to move in the 3D space to see. </p>

	<p>Week 4: Create poses we are satisfied with on our 3D articulated model penguin and mark them as new spatial key frames. Debug our project and work on the webpage 
		of our final implementation that explains our process and challenges.</p>
	    
	    <p> Here is a link to our video summary: https://youtu.be/Hi6UZgm5pqI </p>
           
     
    </div>
</body>
</html>
